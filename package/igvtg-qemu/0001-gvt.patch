diff --git a/Makefile.target b/Makefile.target
index 4d56298bbf..a6bb1c0584 100644
--- a/Makefile.target
+++ b/Makefile.target
@@ -106,6 +106,7 @@ obj-$(CONFIG_TCG) += fpu/softfloat.o
 obj-y += target/$(TARGET_BASE_ARCH)/
 obj-y += disas.o
 obj-$(call notempty,$(TARGET_XML_FILES)) += gdbstub-xml.o
+obj-$(call lnot,$(CONFIG_VGT)) += hw/display/vgt-stub.o
 
 #########################################################
 # Linux user emulator target
diff --git a/configure b/configure
index 2a7796ea80..5489d11abd 100755
--- a/configure
+++ b/configure
@@ -365,6 +365,7 @@ libattr=""
 xfs=""
 tcg="yes"
 membarrier=""
+vgt="yes"
 vhost_net="no"
 vhost_crypto="no"
 vhost_scsi="no"
@@ -1029,6 +1030,10 @@ for opt do
   ;;
   --with-sdlabi=*) sdlabi="$optarg"
   ;;
+  --disable-vgt) vgt="no"
+  ;;
+  --enable-vgt) vgt="yes"
+  ;;
   --disable-qom-cast-debug) qom_cast_debug="no"
   ;;
   --enable-qom-cast-debug) qom_cast_debug="yes"
@@ -1646,9 +1651,11 @@ disabled with --disable-FEATURE, default is enabled if available:
   nettle          nettle cryptography support
   gcrypt          libgcrypt cryptography support
   sdl             SDL UI
-  --with-sdlabi     select preferred SDL ABI 1.2 or 2.0
+  --with-sdlabi   select preferred SDL ABI 1.2 or 2.0
+  --disable-vgt   disable Intel GVT-g technology
+  --enable-vgt    enable Intel GVT-g technology
   gtk             gtk UI
-  --with-gtkabi     select preferred GTK ABI 2.0 or 3.0
+  --with-gtkabi   select preferred GTK ABI 2.0 or 3.0
   vte             vte support for the gtk UI
   curses          curses UI
   vnc             VNC UI support
@@ -3040,6 +3047,12 @@ EOF
   fi
 fi
 
+##########################################
+# Intel GVT-g detection
+if test "$vgt" = "yes" ; then
+  vgt="yes"
+fi
+
 ##########################################
 # RDMA needs OpenFabrics libraries
 if test "$rdma" != "no" ; then
@@ -5898,6 +5911,7 @@ if test "$darwin" = "yes" ; then
     echo "Cocoa support     $cocoa"
 fi
 echo "SDL support       $sdl $(echo_version $sdl $sdlversion)"
+echo "Intel GVT-g support $vgt"
 echo "GTK support       $gtk $(echo_version $gtk $gtk_version)"
 echo "GTK GL support    $gtk_gl"
 echo "VTE support       $vte $(echo_version $vte $vteversion)"
@@ -6233,6 +6247,9 @@ if test "$sdl" = "yes" ; then
   echo "SDL_CFLAGS=$sdl_cflags" >> $config_host_mak
   echo "SDL_LIBS=$sdl_libs" >> $config_host_mak
 fi
+if test "$vgt" = "yes" ; then
+  echo "CONFIG_VGT=y" >> $config_host_mak
+fi
 if test "$cocoa" = "yes" ; then
   echo "CONFIG_COCOA=y" >> $config_host_mak
 fi
diff --git a/hw/display/Makefile.objs b/hw/display/Makefile.objs
index fb8408c6d0..ed0b0bf0ae 100644
--- a/hw/display/Makefile.objs
+++ b/hw/display/Makefile.objs
@@ -3,6 +3,7 @@ common-obj-y += ramfb-standalone.o
 
 common-obj-$(CONFIG_ADS7846) += ads7846.o
 common-obj-$(CONFIG_VGA_CIRRUS) += cirrus_vga.o
+obj-$(CONFIG_VGT) += vgt_vga.o
 common-obj-$(CONFIG_G364FB) += g364fb.o
 common-obj-$(CONFIG_JAZZ_LED) += jazz_led.o
 common-obj-$(CONFIG_PL110) += pl110.o
diff --git a/hw/display/vga.c b/hw/display/vga.c
index 802cfd47db..495522f364 100644
--- a/hw/display/vga.c
+++ b/hw/display/vga.c
@@ -724,8 +724,15 @@ uint32_t vbe_ioport_read_data(void *opaque, uint32_t addr)
     } else if (s->vbe_index == VBE_DISPI_INDEX_VIDEO_MEMORY_64K) {
         val = s->vbe_size / (64 * KiB);
     } else {
-        val = 0;
-    }
+        switch (s->vbe_index) {
+           case VBE_DISPI_INDEX_LFB_ADDRESS_H:
+               val = VBE_DISPI_LFB_PHYSICAL_ADDRESS >> 16;
+               break;
+           default:
+               val = 0;
+               break;
+       }
+   }
     trace_vga_vbe_read(s->vbe_index, val);
     return val;
 }
diff --git a/hw/display/vga_int.h b/hw/display/vga_int.h
index 339661bc01..bfd88305f1 100644
--- a/hw/display/vga_int.h
+++ b/hw/display/vga_int.h
@@ -34,6 +34,40 @@
 #define ST01_V_RETRACE      0x08
 #define ST01_DISP_ENABLE    0x01
 
+#define VBE_DISPI_MAX_XRES              16000
+#define VBE_DISPI_MAX_YRES              12000
+#define VBE_DISPI_MAX_BPP               32
+
+#define VBE_DISPI_INDEX_ID              0x0
+#define VBE_DISPI_INDEX_XRES            0x1
+#define VBE_DISPI_INDEX_YRES            0x2
+#define VBE_DISPI_INDEX_BPP             0x3
+#define VBE_DISPI_INDEX_ENABLE          0x4
+#define VBE_DISPI_INDEX_BANK            0x5
+#define VBE_DISPI_INDEX_VIRT_WIDTH      0x6
+#define VBE_DISPI_INDEX_VIRT_HEIGHT     0x7
+#define VBE_DISPI_INDEX_X_OFFSET        0x8
+#define VBE_DISPI_INDEX_Y_OFFSET        0x9
+#define VBE_DISPI_INDEX_NB              0xa /* size of vbe_regs[] */
+#define VBE_DISPI_INDEX_VIDEO_MEMORY_64K 0xa /* read-only, not in vbe_regs */
+#define VBE_DISPI_INDEX_LFB_ADDRESS_H    0xb
+
+#define VBE_DISPI_ID0                   0xB0C0
+#define VBE_DISPI_ID1                   0xB0C1
+#define VBE_DISPI_ID2                   0xB0C2
+#define VBE_DISPI_ID3                   0xB0C3
+#define VBE_DISPI_ID4                   0xB0C4
+#define VBE_DISPI_ID5                   0xB0C5
+
+#define VBE_DISPI_DISABLED              0x00
+#define VBE_DISPI_ENABLED               0x01
+#define VBE_DISPI_GETCAPS               0x02
+#define VBE_DISPI_8BIT_DAC              0x20
+#define VBE_DISPI_LFB_ENABLED           0x40
+#define VBE_DISPI_NOCLEARMEM            0x80
+
+#define VBE_DISPI_LFB_PHYSICAL_ADDRESS  0xE0000000
+
 #define CH_ATTR_SIZE (160 * 100)
 #define VGA_MAX_HEIGHT 2048
 
diff --git a/hw/display/vgt-stub.c b/hw/display/vgt-stub.c
new file mode 100644
index 0000000000..f6571ba48e
--- /dev/null
+++ b/hw/display/vgt-stub.c
@@ -0,0 +1,32 @@
+/*
+ * QEMU VGT support
+ *
+ * Copyright (c) Intel
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.  See
+ * the COPYING file in the top-level directory.
+ *
+ */
+#include "hw/hw.h"
+#include "ui/console.h"
+#include "hw/i386/pc.h"
+
+DeviceState *vgt_vga_init(PCIBus *pci_bus)
+{
+    return NULL;
+}
+
+void vgt_bridge_pci_conf_init(PCIDevice *pdev)
+{
+}
+
+void vgt_kvm_set_opregion_addr(uint32_t addr)
+{
+}
+
+void vgt_bridge_pci_write(PCIDevice *dev,
+                          uint32_t address, uint32_t val, int len)
+{
+}
+
+
diff --git a/hw/display/vgt_vga.c b/hw/display/vgt_vga.c
new file mode 100644
index 0000000000..27ecf57a27
--- /dev/null
+++ b/hw/display/vgt_vga.c
@@ -0,0 +1,558 @@
+/*
+ * QEMU vGT/XenGT Legacy VGA support
+ *
+ * Copyright (c) 2003 Fabrice Bellard
+ * Copyright (c) Citrix Systems, Inc
+ * Copyright (c) Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+#include "qemu/osdep.h"
+#include "hw/hw.h"
+#include "ui/console.h"
+#include "hw/i386/pc.h"
+#include "hw/pci/pci.h"
+#include "hw/pci/pci_host.h"
+#include "hw/pci/pci_bridge.h"
+#include "hw/pci/pci_bus.h"
+#include "vga_int.h"
+#include "ui/pixel_ops.h"
+#include "qemu/timer.h"
+#include "hw/loader.h"
+#include "qemu/log.h"
+#include "sysemu/arch_init.h"
+#include "hw/xen/xen.h"
+#include "hw/display/vga.h"
+
+#define DEBUG_VGT
+
+#ifdef DEBUG_VGT
+#define DPRINTF(fmt, ...) \
+    do { fprintf(stderr, "vgt: " fmt, ## __VA_ARGS__); } while (0)
+#else
+#define DPRINTF(fmt, ...) \
+    do { } while (0)
+#endif
+
+typedef struct VGTHostDevice {
+    PCIHostDeviceAddress addr;
+    int config_fd;
+} VGTHostDevice;
+
+typedef struct VGTVMState {
+     struct VGACommonState vga;
+     struct VGTVGAState* parent;
+} VGTVMState;
+
+typedef struct VGTVGAState {
+    PCIDevice dev;
+    struct VGTVMState state;
+    int num_displays;
+    VGTHostDevice host_dev;
+    bool instance_created;
+    int domid;
+} VGTVGAState;
+
+/* These are the default values */
+int vgt_low_gm_sz = 64; /* in MB */
+int vgt_high_gm_sz = 448; /* in MB */
+int vgt_fence_sz = 4;
+int vgt_primary = 1; /* -1 means "not specified */
+int guest_domid = 0;
+
+static int vgt_host_pci_cfg_get(VGTHostDevice *host_dev,
+                                void *data, int len, uint32_t addr);
+static void cpu_update_state(void *pv, int running, RunState state);
+ 
+
+void vgt_bridge_pci_write(PCIDevice *dev,
+                          uint32_t address, uint32_t val, int len)
+{
+    assert(dev->devfn == 0x00);
+
+    i440fx_write_config(dev, address, val, len);
+}
+
+/*
+ *  Inform vGT driver to create a vGT instance
+ */
+static void create_vgt_instance(VGTVGAState *vdev)
+{
+    /* FIXME: this should be substituded as a environment variable */
+    const char *path = "/sys/kernel/vgt/control/create_vgt_instance";
+    FILE *vgt_file;
+    int err = 0;
+    int domid = vdev->domid;
+  
+    qemu_log("vGT: %s: domid=%d, low_gm_sz=%dMB, high_gm_sz=%dMB, "
+        "fence_sz=%d, vgt_primary=%d\n", __func__, domid,
+        vgt_low_gm_sz, vgt_high_gm_sz, vgt_fence_sz, vgt_primary);
+    if (vgt_low_gm_sz <= 0 || vgt_high_gm_sz <=0 ||
+		vgt_primary < -1 || vgt_primary > 1 ||
+        vgt_fence_sz <=0) {
+        qemu_log("vGT: %s failed: invalid parameters!\n", __func__);
+        abort();
+    }
+
+    if ((vgt_file = fopen(path, "w")) == NULL) {
+        err = errno;
+        qemu_log("vGT: open %s failed\n", path);
+    }
+    /* The format of the string is:
+     * domid,aperture_size,gm_size,fence_size. This means we want the vgt
+     * driver to create a vgt instanc for Domain domid with the required
+     * parameters. NOTE: aperture_size and gm_size are in MB.
+     */
+    if (!err && fprintf(vgt_file, "%d,%u,%u,%u,%d,0\n", domid,
+        vgt_low_gm_sz, vgt_high_gm_sz, vgt_fence_sz, vgt_primary) < 0) {
+        err = errno;
+    }
+
+    if (!err && fclose(vgt_file) != 0) {
+        err = errno;
+    }
+
+    if (err) {
+        qemu_log("vGT: %s failed: errno=%d\n", __func__, err);
+        exit(-1);
+    }
+
+    vdev->instance_created = TRUE;
+}
+
+/*
+ *  Inform vGT driver to close a vGT instance
+ */
+static void destroy_vgt_instance(int domid)
+{
+    const char *path = "/sys/kernel/vgt/control/create_vgt_instance";
+    FILE *vgt_file;
+    int err = 0;
+
+    if ((vgt_file = fopen(path, "w")) == NULL) {
+        error_report("vgt: error: open %s failed", path);
+        err = errno;
+    }
+
+    /* -domid means we want the vgt driver to free the vgt instance
+     * of Domain domid.
+     * */
+    if (!err && fprintf(vgt_file, "%d\n", -domid) < 0) {
+        err = errno;
+    }
+
+    if (!err && fclose(vgt_file) != 0) {
+        err = errno;
+    }
+
+    if (err) {
+        qemu_log("vGT: %s: failed: errno=%d\n", __func__, err);
+        exit(-1);
+    }
+}
+
+static int pch_map_irq(PCIDevice *pci_dev, int irq_num)
+{
+    return irq_num;
+}
+
+static int vgt_host_device_get(VGTHostDevice *dev)
+{
+    char name[PATH_MAX];
+
+    snprintf(name, sizeof(name), "/sys/bus/pci/devices/%04x:%02x:%02x.%x/config",
+             dev->addr.domain, dev->addr.bus, dev->addr.slot, dev->addr.function);
+    dev->config_fd = open(name, O_RDONLY);
+    if (dev->config_fd == -1) {
+        error_report("vgt:open failed: %s\n", strerror(errno));
+        return -1;
+     }
+
+    return 0;
+}
+
+static void vgt_host_device_put(VGTHostDevice *dev)
+{
+    if (dev->config_fd >= 0) {
+        close(dev->config_fd);
+        dev->config_fd = -1;
+    }
+}
+
+static int vgt_host_pci_cfg_get(VGTHostDevice *host_dev,
+                                void *data, int len, uint32_t addr)
+{
+    int ret;
+
+    vgt_host_device_get(host_dev);
+    ret = pread(host_dev->config_fd, data, len, addr);
+    if (ret < len) {
+        ret = ret < 0 ? -errno : -EFAULT;
+        error_report("failed to read device config space: %m");
+        goto out;
+    }
+
+out:
+    vgt_host_device_put(host_dev);
+    return ret;
+}
+
+static void vgt_host_bridge_cap_init(PCIDevice *dev, VGTHostDevice *host_dev)
+{
+    assert(dev->devfn == 0x00);
+    uint8_t cap_ptr = 0;
+
+    vgt_host_pci_cfg_get(host_dev, &cap_ptr, 1, PCI_CAPABILITY_LIST);
+    while (cap_ptr !=0) {
+        vgt_host_pci_cfg_get(host_dev, dev->config + cap_ptr, 4, cap_ptr);
+        vgt_host_pci_cfg_get(host_dev, dev->config + cap_ptr + 4, 4,
+                             cap_ptr + 4);
+        vgt_host_pci_cfg_get(host_dev, dev->config + cap_ptr + 8, 4,
+                             cap_ptr + 8);
+        vgt_host_pci_cfg_get(host_dev, dev->config + cap_ptr + 12, 4,
+                             cap_ptr + 12);
+        vgt_host_pci_cfg_get(host_dev, &cap_ptr, 1, cap_ptr + 1);
+    }
+}
+
+static void vgt_host_dev_init(PCIDevice *pdev, VGTHostDevice *host_dev)
+{
+    assert(pdev != NULL && host_dev != NULL);
+
+    host_dev->addr.domain = 0;
+    host_dev->addr.bus = pci_dev_bus_num(pdev);
+    host_dev->addr.slot = PCI_SLOT(pdev->devfn);
+    host_dev->addr.function = PCI_FUNC(pdev->devfn);
+}
+
+void vgt_bridge_pci_conf_init(PCIDevice *pdev)
+{
+    printf("vgt_bridge_pci_conf_init\n");
+    VGTHostDevice host_dev;
+
+    vgt_host_dev_init(pdev, &host_dev);
+
+    vgt_host_pci_cfg_get(&host_dev, pdev->config, 2, 0x00);
+    printf("vendor id: %x\n", *(uint16_t *)((char *)pdev->config + 0x00));
+
+    vgt_host_pci_cfg_get(&host_dev, pdev->config + 0x02, 2, 0x02);
+    printf("device id: %x\n", *(uint16_t *)((char *)pdev->config + 0x02));
+    /* status */
+    vgt_host_pci_cfg_get(&host_dev, pdev->config + 0x06, 2, 0x06);
+    /* revision id */
+    vgt_host_pci_cfg_get(&host_dev, pdev->config + 0x08, 2, 0x08);
+    /* capability */
+    vgt_host_pci_cfg_get(&host_dev, pdev->config + 0x34, 1, 0x34);
+    vgt_host_bridge_cap_init(pdev, &host_dev);
+
+    /* SNB: processor graphics control register */
+    vgt_host_pci_cfg_get(&host_dev, pdev->config + 0x50, 2, 0x50);
+    /* processor graphics control register */
+    vgt_host_pci_cfg_get(&host_dev, pdev->config + 0x52, 2, 0x52);
+}
+
+static void vgt_reset(DeviceState *dev)
+{
+    PCIDevice *pdev = DO_UPCAST(PCIDevice, qdev, dev);
+    VGTVGAState *d = DO_UPCAST(VGTVGAState, dev, pdev);
+
+    if (d->instance_created) {
+        destroy_vgt_instance(d->domid);
+    }
+
+    create_vgt_instance(d);
+}
+
+static void vgt_cleanupfn(PCIDevice *dev)
+{
+    VGTVGAState *d = DO_UPCAST(VGTVGAState, dev, dev);
+
+    if (d->instance_created) {
+        destroy_vgt_instance(d->domid);
+    }
+}
+
+static int vgt_get_domid(void)
+{
+    int domid = 0;
+
+    if (xen_enabled()) {
+        domid = xen_domid;
+    }
+    assert(domid > 0);
+    guest_domid = domid;
+
+    return domid;
+}
+
+static void vgt_initfn(PCIDevice *dev, Error **errp)
+{
+    VGTVGAState *d = DO_UPCAST(VGTVGAState, dev, dev);
+
+    DPRINTF("vgt_initfn\n");
+    vgt_host_dev_init(dev, &d->host_dev);
+    d->domid = vgt_get_domid();
+    d->state.parent = d;
+    qemu_add_vm_change_state_handler(cpu_update_state, d);
+}
+
+DeviceState *vgt_vga_init(PCIBus *pci_bus)
+{
+    PCIDevice *dev;
+    PCIBridge *br;
+    uint16_t vendor_id;
+    uint16_t device_id;
+    uint8_t revision_id;
+    uint16_t class_dev;
+    VGTHostDevice host_dev = {
+        .addr.domain = 0,
+        .addr.bus = 0,
+        .addr.slot = 0x1f,
+        .addr.function = 0,
+    };
+
+    vgt_host_pci_cfg_get(&host_dev, &vendor_id, sizeof(vendor_id),
+                         PCI_VENDOR_ID);
+    vgt_host_pci_cfg_get(&host_dev, &device_id, sizeof(device_id),
+                         PCI_DEVICE_ID);
+    vgt_host_pci_cfg_get(&host_dev, &revision_id, sizeof(revision_id),
+                         PCI_REVISION_ID);
+    vgt_host_pci_cfg_get(&host_dev, &class_dev, sizeof(class_dev),
+                         PCI_CLASS_DEVICE);
+    DPRINTF("vendor: 0x%hx, device: 0x%hx, revision: 0x%hhx\n",
+            vendor_id, device_id, revision_id);
+
+    if (vendor_id != PCI_VENDOR_ID_INTEL) {
+        error_report("vgt: error: vgt-vga is only supported on Intel GPUs");
+        return NULL;
+    }
+
+    dev = pci_create_multifunction(pci_bus, PCI_DEVFN(0x1f, 0), true,
+                                   "vgt-isa");
+    if (!dev) {
+        error_report("vgt: error: vgt-isa not available");
+        return NULL;
+    }
+
+    qdev_init_nofail(&dev->qdev);
+
+    pci_config_set_vendor_id(dev->config, vendor_id);
+    pci_config_set_device_id(dev->config, device_id);
+    pci_config_set_revision(dev->config, revision_id);
+    pci_config_set_class(dev->config, class_dev);
+    br = PCI_BRIDGE(dev);
+    pci_bridge_map_irq(br, "IGD Bridge",
+                       pch_map_irq);
+
+    printf("Create vgt ISA bridge successfully\n");
+
+    dev = pci_create_multifunction(pci_bus, PCI_DEVFN(0x2, 0), true,
+                                   "vgt-vga");
+    if (!dev) {
+        error_report("vgt: error: vgt-vga not available");
+        return NULL;
+    }
+
+    qdev_init_nofail(&dev->qdev);
+    printf("Create vgt VGA successfully\n");
+    return DEVICE(dev);
+}
+
+static void vgt_pause(int domid, bool dev_state)
+{
+    char file_name[PATH_MAX] = {0};
+    FILE *fp = NULL;
+    int err = 0;
+
+    snprintf(file_name, PATH_MAX, "/sys/kernel/vgt/vm%d/schedule", domid);
+
+    fp = fopen(file_name, "w");
+    if (fp == NULL) {
+        err = errno;
+        qemu_log("vGT: open %s failed\n", file_name);
+    }
+
+    if (!err && fprintf(fp, "%d\n", !dev_state) < 0) {
+        err = errno;
+    }
+
+    if (!err && fclose(fp) != 0) {
+        err = errno;
+    }
+
+    if (err) {
+        qemu_log("vGT: %s failed: errno=%d\n", __func__, err);
+        exit(-1);
+    }
+}
+
+static void cpu_update_state(void *pv, int running, RunState state)
+{
+    VGTVGAState *d = (VGTVGAState *) pv;
+    if (!running) {
+        vgt_pause(d->domid, true);
+    }
+}
+
+static void read_write_state(QEMUFile *f, VGTVGAState *d, bool is_read)
+{
+    char file_name[PATH_MAX] = {0};
+    FILE *fp = NULL;
+    struct stat st;
+    int sz;
+    uint8_t *buf = NULL;
+    int count = 0;
+
+    snprintf(file_name, PATH_MAX, "/sys/kernel/vgt/vm%d/device_state", d->domid);
+
+    fp = fopen(file_name, "r+");
+    if (fp == NULL) {
+        qemu_log("vGT: %s failed to open file %s! errno = %d",
+                __func__, file_name, errno);
+        goto EXIT;
+    }
+
+    fstat(fileno(fp), &st);
+    sz = st.st_size;
+
+    if (sz <= 0) {
+        qemu_log("vGT: failed to achieve file size. file name=%s",
+               file_name);
+        goto EXIT;
+    }
+
+    buf = g_malloc(sz);
+    if (buf == NULL) {
+        qemu_log("vGT: %s failed to allocate memory size %d! errno = %d",
+                __func__, sz, errno);
+        goto EXIT;
+    }
+
+    DPRINTF("Allocate %d size of buffer for device state\n", sz);
+
+    if (is_read) {
+        count = fread(buf, 1, sz, fp);
+        qemu_put_buffer(f, buf, sz);
+    } else {
+        qemu_get_buffer(f, buf, sz);
+        count = fwrite(buf, 1, sz, fp);
+    }
+
+    if (count != sz) {
+        qemu_log("vGT: read/write snapshot file size is differ %d:%d",
+                count, sz);
+    }
+
+    DPRINTF("[%s] %d size of buffer for device state\n",
+            is_read ? "READ":"WRITE", count);
+
+EXIT:
+    g_free(buf);
+    if (fp) {
+        fclose(fp);
+    }
+    return;
+}
+
+static int vgt_device_get(QEMUFile *f, void *pv,
+                          size_t size, VMStateField *field)
+{
+    VGTVGAState *d = (VGTVGAState *) pv;
+
+    read_write_state(f, d, false);
+
+    vgt_pause(d->domid, false);
+    return 0;
+}
+
+static int vgt_device_put(QEMUFile *f, void *pv, size_t size,
+                          VMStateField *field, QJSON *vmdesc)
+{
+    VGTVGAState *d = (VGTVGAState *) pv;
+
+    read_write_state(f, d, true);
+
+    destroy_vgt_instance(d->domid);
+    return 0;
+}
+
+static const VMStateInfo vmstate_info_vgt = {
+    .name = "vgt state",
+    .get  = vgt_device_get,
+    .put  = vgt_device_put,
+};
+
+static const VMStateDescription vmstate_vga_vgt = {
+    .name = "vgt-vga",
+    .version_id = 2,
+    .minimum_version_id = 2,
+    .fields = (VMStateField[]) {
+        {
+            .name         = "vgt dev",
+            .version_id   = 0,
+            .field_exists = NULL,
+            .size         = 0,
+            .info         = &vmstate_info_vgt,
+            .flags        = VMS_SINGLE,
+            .offset       = 0,
+        },
+
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static void vgt_class_initfn(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    PCIDeviceClass *ic = PCI_DEVICE_CLASS(klass);
+    ic->realize = vgt_initfn;
+    dc->reset = vgt_reset;
+    ic->exit = vgt_cleanupfn;
+    dc->vmsd = &vmstate_vga_vgt;
+}
+
+static TypeInfo vgt_info = {
+    .name          = "vgt-vga",
+    .parent        = TYPE_PCI_DEVICE,
+    .instance_size = sizeof(VGTVGAState),
+    .class_init    = vgt_class_initfn,
+    .interfaces = (InterfaceInfo[]) {
+        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
+        { }
+    },
+};
+
+static TypeInfo isa_info = {
+    .name          = "vgt-isa",
+    .parent        = TYPE_PCI_BRIDGE,
+    .instance_size = sizeof(PCIBridge),
+    .interfaces = (InterfaceInfo[]) {
+        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
+        { }
+    },
+
+};
+
+static void vgt_register_types(void)
+{
+    type_register_static(&vgt_info);
+    type_register_static(&isa_info);
+}
+
+type_init(vgt_register_types)
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index dc09466b3e..2114e90ae3 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -58,6 +58,7 @@
 #include "migration/misc.h"
 #include "kvm_i386.h"
 #include "sysemu/numa.h"
+#include "hw/display/vga.h"
 
 #define MAX_IDE_BUS 2
 
@@ -230,7 +231,19 @@ static void pc_init1(MachineState *machine,
 
     pc_register_ferr_irq(pcms->gsi[13]);
 
-    pc_vga_init(isa_bus, pcmc->pci_enabled ? pci_bus : NULL);
+    /*
+     * Initialize XenGT hooks before normal VGA init. The
+     * ideal case is to have IGD presented as the primary
+     * graphics card in 00:02.0, and then have other emulated
+     * PCI VGA card all disabled. We still rely on Qemu to
+     * emulate legacy ISA ports, so requires the ISA vga logic.
+     */
+    if (vgt_vga_enabled && pcmc->pci_enabled) {
+        vgt_vga_init(pci_bus);
+        isa_create_simple(isa_bus, "isa-vga");
+    } else {
+        pc_vga_init(isa_bus, pcmc->pci_enabled ? pci_bus : NULL);
+    }
 
     assert(pcms->vmport != ON_OFF_AUTO__MAX);
     if (pcms->vmport == ON_OFF_AUTO_AUTO) {
diff --git a/hw/i386/xen/xen-hvm.c b/hw/i386/xen/xen-hvm.c
index 935a3676c8..0507630fa0 100644
--- a/hw/i386/xen/xen-hvm.c
+++ b/hw/i386/xen/xen-hvm.c
@@ -206,7 +206,11 @@ static void xen_ram_init(PCMachineState *pcms,
         user_lowmem = HVM_BELOW_4G_RAM_END;
     }
 
-    if (ram_size >= user_lowmem) {
+    if (vgt_vga_enabled &&
+        ram_size >= 0xc0000000) {
+        pcms->above_4g_mem_size = ram_size - 0xc0000000;
+        pcms->below_4g_mem_size = 0xc0000000;
+    } else if (ram_size >= user_lowmem) {
         pcms->above_4g_mem_size = ram_size - user_lowmem;
         pcms->below_4g_mem_size = user_lowmem;
     } else {
diff --git a/hw/pci-host/piix.c b/hw/pci-host/piix.c
index 0e608347c1..8371ab762e 100644
--- a/hw/pci-host/piix.c
+++ b/hw/pci-host/piix.c
@@ -37,6 +37,7 @@
 #include "hw/i386/ioapic.h"
 #include "qapi/visitor.h"
 #include "qemu/error-report.h"
+#include "hw/display/vga.h"
 
 /*
  * I440FX chipset data sheet.
@@ -154,8 +155,8 @@ static void i440fx_update_memory_mappings(PCII440FXState *d)
 }
 
 
-static void i440fx_write_config(PCIDevice *dev,
-                                uint32_t address, uint32_t val, int len)
+void i440fx_write_config(PCIDevice *dev,
+                         uint32_t address, uint32_t val, int len)
 {
     PCII440FXState *d = I440FX_PCI_DEVICE(dev);
 
@@ -336,6 +337,10 @@ static void i440fx_realize(PCIDevice *dev, Error **errp)
     if (object_property_get_bool(qdev_get_machine(), "iommu", NULL)) {
         warn_report("i440fx doesn't support emulated iommu");
     }
+
+    if (vgt_vga_enabled && xen_enabled()) {
+        vgt_bridge_pci_conf_init(dev);
+    }
 }
 
 PCIBus *i440fx_init(const char *host_type, const char *pci_type,
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index 80bc45930d..c61f3f96c8 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -24,6 +24,7 @@
 
 #include "qemu/osdep.h"
 #include "hw/hw.h"
+#include "hw/i386/pc.h"
 #include "hw/pci/pci.h"
 #include "hw/pci/pci_bridge.h"
 #include "hw/pci/pci_bus.h"
@@ -43,6 +44,7 @@
 #include "qapi/error.h"
 #include "qapi/qapi-commands-misc.h"
 #include "qemu/cutils.h"
+#include "hw/display/vga.h"
 
 //#define DEBUG_PCI
 #ifdef DEBUG_PCI
@@ -986,6 +988,10 @@ static PCIDevice *do_pci_register_device(PCIDevice *pci_dev,
     if (devfn < 0) {
         for(devfn = bus->devfn_min ; devfn < ARRAY_SIZE(bus->devices);
             devfn += PCI_FUNC_MAX) {
+            /* If vGT/XenGT is in use, reserve 00:02.* for the IGD */
+            if ((vgt_vga_enabled) && devfn == 0x10)
+                continue;
+
             if (pci_bus_devfn_available(bus, devfn) &&
                    !pci_bus_devfn_reserved(bus, devfn)) {
                 goto found;
@@ -1032,6 +1038,7 @@ static PCIDevice *do_pci_register_device(PCIDevice *pci_dev,
     pci_dev->irq_state = 0;
     pci_config_alloc(pci_dev);
 
+    printf("set vendor id(%x) for devfn(%x)\n", pc->vendor_id, devfn);
     pci_config_set_vendor_id(pci_dev->config, pc->vendor_id);
     pci_config_set_device_id(pci_dev->config, pc->device_id);
     pci_config_set_revision(pci_dev->config, pc->revision);
@@ -1068,6 +1075,11 @@ static PCIDevice *do_pci_register_device(PCIDevice *pci_dev,
         config_read = pci_default_read_config;
     if (!config_write)
         config_write = pci_default_write_config;
+    if (vgt_vga_enabled &&
+        config_write == i440fx_write_config) {
+        config_write = vgt_bridge_pci_write;
+    }
+
     pci_dev->config_read = config_read;
     pci_dev->config_write = config_write;
     bus->devices[devfn] = pci_dev;
diff --git a/hw/vfio/common.c b/hw/vfio/common.c
index fb396cf00a..df5e0adc44 100644
--- a/hw/vfio/common.c
+++ b/hw/vfio/common.c
@@ -35,6 +35,7 @@
 #include "sysemu/kvm.h"
 #include "trace.h"
 #include "qapi/error.h"
+#include "exec/ram_addr.h"
 
 struct vfio_group_head vfio_group_list =
     QLIST_HEAD_INITIALIZER(vfio_group_list);
@@ -697,9 +698,42 @@ static void vfio_listener_region_del(MemoryListener *listener,
     }
 }
 
+static void vfio_log_sync(MemoryListener *listener,
+                          MemoryRegionSection *section)
+{
+    VFIOContainer *container = container_of(listener, VFIOContainer, listener);
+    VFIOGroup *group = QLIST_FIRST(&container->group_list);
+    VFIODevice *vbasedev;
+    QLIST_FOREACH(vbasedev, &group->device_list, next) {
+        if (vbasedev->device_state == VFIO_DEVICE_START) {
+            return;
+        }
+    }
+
+    struct vfio_iommu_get_dirty_bitmap *d;
+    ram_addr_t size = int128_get64(section->size);
+    unsigned long page_nr = size >> TARGET_PAGE_BITS;
+    unsigned long bitmap_size =
+                    (BITS_TO_LONGS(page_nr) + 1) * sizeof(unsigned long);
+    d = g_malloc0(sizeof(*d) + bitmap_size);
+    d->start_addr = section->offset_within_address_space;
+    d->page_nr = page_nr;
+
+    if (ioctl(container->fd, VFIO_IOMMU_GET_DIRTY_BITMAP, d)) {
+        error_report("vfio: Failed to fetch dirty pages for migration");
+        goto exit;
+    }
+
+    cpu_physical_memory_set_dirty_lebitmap((unsigned long *)&d->dirty_bitmap,
+                                           d->start_addr, d->page_nr);
+exit:
+    g_free(d);
+}
+
 static const MemoryListener vfio_memory_listener = {
     .region_add = vfio_listener_region_add,
     .region_del = vfio_listener_region_del,
+    .log_sync = vfio_log_sync,
 };
 
 static void vfio_listener_release(VFIOContainer *container)
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 6cbb8fa054..73c0562aed 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -34,11 +34,17 @@
 #include "pci.h"
 #include "trace.h"
 #include "qapi/error.h"
+#include "migration/blocker.h"
+#include "migration/register.h"
 
 #define MSIX_CAP_LENGTH 12
 
+#define VFIO_SAVE_FLAG_SETUP 0
+#define VFIO_SAVE_FLAG_DEV_STATE 1
+
 static void vfio_disable_interrupts(VFIOPCIDevice *vdev);
 static void vfio_mmap_set_enabled(VFIOPCIDevice *vdev, bool enabled);
+static void vfio_vm_change_state_handler(void *pv, int running, RunState state);
 
 /*
  * Disabling BAR mmaping can be slow, but toggling it around INTx can
@@ -2799,6 +2805,150 @@ static void vfio_unregister_req_notifier(VFIOPCIDevice *vdev)
     vdev->req_enabled = false;
 }
 
+static void vfio_save_live_pending(QEMUFile *f, void *opaque,
+                                   uint64_t max_size,
+                                   uint64_t *res_precopy_only,
+                                   uint64_t *res_compatible,
+                                   uint64_t *res_post_copy_only)
+{
+
+}
+
+static int vfio_load(QEMUFile *f, void *opaque, int version_id)
+{
+    VFIOPCIDevice *vdev = opaque;
+    PCIDevice *pdev = &vdev->pdev;
+    int sz = vdev->device_state.size - VFIO_DEVICE_STATE_OFFSET;
+    uint8_t *buf = NULL;
+    uint32_t ctl, msi_lo, msi_hi, msi_data, bar_cfg, i;
+    bool msi_64bit;
+
+    if (qemu_get_byte(f) == VFIO_SAVE_FLAG_SETUP) {
+        goto exit;
+    }
+
+    /* retore pci bar configuration */
+    ctl = pci_default_read_config(pdev, PCI_COMMAND, 2);
+    vfio_pci_write_config(pdev, PCI_COMMAND,
+                          ctl & (!(PCI_COMMAND_IO | PCI_COMMAND_MEMORY)), 2);
+    for (i = 0; i < PCI_ROM_SLOT; i++) {
+        bar_cfg = qemu_get_be32(f);
+        vfio_pci_write_config(pdev, PCI_BASE_ADDRESS_0 + i * 4, bar_cfg, 4);
+    }
+    vfio_pci_write_config(pdev, PCI_COMMAND,
+                          ctl | PCI_COMMAND_IO | PCI_COMMAND_MEMORY, 2);
+
+    /* restore msi configuration */
+    ctl = pci_default_read_config(pdev, pdev->msi_cap + PCI_MSI_FLAGS, 2);
+    msi_64bit = !!(ctl & PCI_MSI_FLAGS_64BIT);
+
+    vfio_pci_write_config(&vdev->pdev,
+                          pdev->msi_cap + PCI_MSI_FLAGS,
+                          ctl & (!PCI_MSI_FLAGS_ENABLE), 2);
+
+    msi_lo = qemu_get_be32(f);
+    vfio_pci_write_config(pdev, pdev->msi_cap + PCI_MSI_ADDRESS_LO, msi_lo, 4);
+
+    if (msi_64bit) {
+        msi_hi = qemu_get_be32(f);
+        vfio_pci_write_config(pdev, pdev->msi_cap + PCI_MSI_ADDRESS_HI,
+                              msi_hi, 4);
+    }
+    msi_data = qemu_get_be32(f);
+    vfio_pci_write_config(pdev,
+              pdev->msi_cap + (msi_64bit ? PCI_MSI_DATA_64 : PCI_MSI_DATA_32),
+              msi_data, 2);
+
+    vfio_pci_write_config(&vdev->pdev, pdev->msi_cap + PCI_MSI_FLAGS,
+                          ctl | PCI_MSI_FLAGS_ENABLE, 2);
+
+    buf = g_malloc(sz);
+    if (buf == NULL) {
+        error_report("vfio: Failed to allocate memory for migrate");
+        return -1;
+    }
+
+    qemu_get_buffer(f, buf, sz);
+    if (pwrite(vdev->vbasedev.fd, buf, sz,
+               vdev->device_state.offset + VFIO_DEVICE_STATE_OFFSET) != sz) {
+        error_report("vfio: Failed to write Device State Region");
+        return -1;
+    }
+
+    g_free(buf);
+
+exit:
+    return 0;
+}
+
+static int vfio_save_complete(QEMUFile *f, void *opaque)
+{
+    VFIOPCIDevice *vdev = opaque;
+    PCIDevice *pdev = &vdev->pdev;
+    int sz = vdev->device_state.size - VFIO_DEVICE_STATE_OFFSET;
+    uint8_t *buf = NULL;
+    uint32_t msi_cfg, msi_lo, msi_hi, msi_data, bar_cfg, i;
+    bool msi_64bit;
+
+    qemu_put_byte(f, VFIO_SAVE_FLAG_DEV_STATE);
+
+    for (i = 0; i < PCI_ROM_SLOT; i++) {
+        bar_cfg = pci_default_read_config(pdev, PCI_BASE_ADDRESS_0 + i * 4, 4);
+        qemu_put_be32(f, bar_cfg);
+    }
+
+    msi_cfg = pci_default_read_config(pdev, pdev->msi_cap + PCI_MSI_FLAGS, 2);
+    msi_64bit = !!(msi_cfg & PCI_MSI_FLAGS_64BIT);
+
+    msi_lo = pci_default_read_config(pdev,
+                                     pdev->msi_cap + PCI_MSI_ADDRESS_LO, 4);
+    qemu_put_be32(f, msi_lo);
+
+    if (msi_64bit) {
+        msi_hi = pci_default_read_config(pdev,
+                                         pdev->msi_cap + PCI_MSI_ADDRESS_HI,
+                                         4);
+        qemu_put_be32(f, msi_hi);
+    }
+
+    msi_data = pci_default_read_config(pdev,
+               pdev->msi_cap + (msi_64bit ? PCI_MSI_DATA_64 : PCI_MSI_DATA_32),
+               2);
+    qemu_put_be32(f, msi_data);
+
+    buf = g_malloc(sz);
+    if (buf == NULL) {
+        error_report("vfio: Failed to allocate memory for migrate");
+        goto exit;
+    }
+
+    if (pread(vdev->vbasedev.fd, buf, sz,
+              vdev->device_state.offset + VFIO_DEVICE_STATE_OFFSET) != sz) {
+        error_report("vfio: Failed to read Device State Region");
+        goto exit;
+    }
+
+    qemu_put_buffer(f, buf, sz);
+
+exit:
+    g_free(buf);
+
+    return 0;
+}
+
+static int vfio_save_setup(QEMUFile *f, void *opaque)
+{
+    qemu_put_byte(f, VFIO_SAVE_FLAG_SETUP);
+    return 0;
+}
+
+static SaveVMHandlers savevm_vfio_handlers = {
+    .save_setup = vfio_save_setup,
+    .save_live_pending = vfio_save_live_pending,
+    .save_live_complete_precopy = vfio_save_complete,
+    .load_state = vfio_load,
+};
+
 static void vfio_realize(PCIDevice *pdev, Error **errp)
 {
     VFIOPCIDevice *vdev = DO_UPCAST(VFIOPCIDevice, pdev, pdev);
@@ -2987,6 +3137,25 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
         vfio_vga_quirk_setup(vdev);
     }
 
+    struct vfio_region_info *device_state;
+    /* device state region setup */
+    if (!vfio_get_dev_region_info(&vdev->vbasedev,
+                VFIO_REGION_TYPE_DEVICE_STATE,
+                VFIO_REGION_SUBTYPE_DEVICE_STATE, &device_state)) {
+        memcpy(&vdev->device_state, device_state,
+               sizeof(struct vfio_region_info));
+        g_free(device_state);
+    } else {
+        error_setg(&vdev->migration_blocker,
+                "Migration disabled: cannot support device state region");
+        migrate_add_blocker(vdev->migration_blocker, &err);
+        if (err) {
+            error_propagate(errp, err);
+            error_free(vdev->migration_blocker);
+            goto error;
+        }
+    }
+
     for (i = 0; i < PCI_ROM_SLOT; i++) {
         vfio_bar_quirk_setup(vdev, i);
     }
@@ -3049,6 +3218,8 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
     vfio_register_err_notifier(vdev);
     vfio_register_req_notifier(vdev);
     vfio_setup_resetfn_quirk(vdev);
+    qemu_add_vm_change_state_handler(vfio_vm_change_state_handler, vdev);
+    register_savevm_live(NULL, "vfio-pci", 0, 1, &savevm_vfio_handlers, vdev);
 
     return;
 
@@ -3057,6 +3228,10 @@ out_teardown:
     vfio_teardown_msi(vdev);
     vfio_bars_exit(vdev);
 error:
+    if (vdev->migration_blocker) {
+        migrate_del_blocker(vdev->migration_blocker);
+        error_free(vdev->migration_blocker);
+    }
     error_prepend(errp, ERR_PREFIX, vdev->vbasedev.name);
 }
 
@@ -3136,6 +3311,24 @@ post_reset:
     vfio_pci_post_reset(vdev);
 }
 
+static void vfio_vm_change_state_handler(void *pv, int running, RunState state)
+{
+    VFIOPCIDevice *vdev = pv;
+    VFIODevice *vbasedev = &vdev->vbasedev;
+    uint8_t dev_state;
+    uint8_t sz = 1;
+
+    dev_state = running ? VFIO_DEVICE_START : VFIO_DEVICE_STOP;
+
+    if (pwrite(vdev->vbasedev.fd, &dev_state,
+               sz, vdev->device_state.offset) != sz) {
+        error_report("vfio: Failed to %s device", running ? "start" : "stop");
+        return;
+    }
+
+    vbasedev->device_state = dev_state;
+}
+
 static void vfio_instance_init(Object *obj)
 {
     PCIDevice *pci_dev = PCI_DEVICE(obj);
@@ -3199,11 +3392,6 @@ static Property vfio_pci_dev_properties[] = {
     DEFINE_PROP_END_OF_LIST(),
 };
 
-static const VMStateDescription vfio_pci_vmstate = {
-    .name = "vfio-pci",
-    .unmigratable = 1,
-};
-
 static void vfio_pci_dev_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(klass);
@@ -3211,7 +3399,6 @@ static void vfio_pci_dev_class_init(ObjectClass *klass, void *data)
 
     dc->reset = vfio_pci_reset;
     dc->props = vfio_pci_dev_properties;
-    dc->vmsd = &vfio_pci_vmstate;
     dc->desc = "VFIO-based PCI device assignment";
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
     pdc->realize = vfio_realize;
diff --git a/hw/vfio/pci.h b/hw/vfio/pci.h
index 52b065421a..cf3f4d4658 100644
--- a/hw/vfio/pci.h
+++ b/hw/vfio/pci.h
@@ -132,6 +132,8 @@ typedef struct VFIOPCIDevice {
     VFIOBAR bars[PCI_NUM_REGIONS - 1]; /* No ROM */
     VFIOVGA *vga; /* 0xa0000, 0x3b0, 0x3c0 */
     void *igd_opregion;
+    struct vfio_region_info device_state;
+    Error *migration_blocker;
     PCIHostDeviceAddress host;
     EventNotifier err_notifier;
     EventNotifier req_notifier;
diff --git a/include/hw/display/vga.h b/include/hw/display/vga.h
index 0401a3a292..011eeb5152 100644
--- a/include/hw/display/vga.h
+++ b/include/hw/display/vga.h
@@ -21,5 +21,13 @@ extern enum vga_retrace_method vga_retrace_method;
 int isa_vga_mm_init(hwaddr vram_base,
                     hwaddr ctrl_base, int it_shift,
                     MemoryRegion *address_space);
+/* vgt_vga.c */
+extern int vgt_low_gm_sz;
+extern int vgt_high_gm_sz;
+extern int vgt_fence_sz;
 
+DeviceState *vgt_vga_init(PCIBus *pci_bus);
+void vgt_bridge_pci_conf_init(PCIDevice *dev);
+void vgt_bridge_pci_write(PCIDevice *dev,
+                          uint32_t address, uint32_t val, int len);
 #endif
diff --git a/include/hw/pci/pci_host.h b/include/hw/pci/pci_host.h
index ba31595fc7..dc7d266838 100644
--- a/include/hw/pci/pci_host.h
+++ b/include/hw/pci/pci_host.h
@@ -70,4 +70,7 @@ extern const MemoryRegionOps pci_host_conf_be_ops;
 extern const MemoryRegionOps pci_host_data_le_ops;
 extern const MemoryRegionOps pci_host_data_be_ops;
 
+void i440fx_write_config(PCIDevice *dev,
+                         uint32_t address, uint32_t val, int len);
+
 #endif /* PCI_HOST_H */
diff --git a/include/hw/vfio/vfio-common.h b/include/hw/vfio/vfio-common.h
index a9036929b2..f305d8181c 100644
--- a/include/hw/vfio/vfio-common.h
+++ b/include/hw/vfio/vfio-common.h
@@ -116,6 +116,7 @@ typedef struct VFIODevice {
     unsigned int num_irqs;
     unsigned int num_regions;
     unsigned int flags;
+    bool device_state;
 } VFIODevice;
 
 struct VFIODeviceOps {
diff --git a/include/sysemu/sysemu.h b/include/sysemu/sysemu.h
index 76ef6196a7..3767220d6f 100644
--- a/include/sysemu/sysemu.h
+++ b/include/sysemu/sysemu.h
@@ -104,12 +104,13 @@ extern int autostart;
 
 typedef enum {
     VGA_NONE, VGA_STD, VGA_CIRRUS, VGA_VMWARE, VGA_XENFB, VGA_QXL,
-    VGA_TCX, VGA_CG3, VGA_DEVICE, VGA_VIRTIO,
+    VGA_TCX, VGA_CG3, VGA_DEVICE, VGA_VIRTIO, VGA_VGT,
     VGA_TYPE_MAX,
 } VGAInterfaceType;
 
 extern int vga_interface_type;
 #define xenfb_enabled (vga_interface_type == VGA_XENFB)
+#define vgt_vga_enabled (vga_interface_type == VGA_VGT)
 
 extern int graphic_width;
 extern int graphic_height;
diff --git a/linux-headers/linux/vfio.h b/linux-headers/linux/vfio.h
index 3615a269d3..32db9b0d3c 100644
--- a/linux-headers/linux/vfio.h
+++ b/linux-headers/linux/vfio.h
@@ -301,6 +301,20 @@ struct vfio_region_info_cap_type {
 #define VFIO_REGION_SUBTYPE_INTEL_IGD_HOST_CFG	(2)
 #define VFIO_REGION_SUBTYPE_INTEL_IGD_LPC_CFG	(3)
 
+/*
+ * The region type device state is for save or restore the vfio device during
+ * migration. 
+ */
+#define VFIO_REGION_TYPE_DEVICE_STATE		(1 << 30)
+/* Mdev sub-type for device state save and restore */
+#define VFIO_REGION_SUBTYPE_DEVICE_STATE	(1)
+
+/* Offset in region to save device state */
+#define VFIO_DEVICE_STATE_OFFSET	1
+
+#define VFIO_DEVICE_START	0
+#define VFIO_DEVICE_STOP	1
+
 /*
  * The MSIX mappable capability informs that MSIX data of a BAR can be mmapped
  * which allows direct access to non-MSIX registers which happened to be within
@@ -665,6 +679,20 @@ struct vfio_iommu_type1_dma_unmap {
 #define VFIO_IOMMU_ENABLE	_IO(VFIO_TYPE, VFIO_BASE + 15)
 #define VFIO_IOMMU_DISABLE	_IO(VFIO_TYPE, VFIO_BASE + 16)
 
+/**
+ * VFIO_IOMMU_GET_DIRTY_BITMAP - _IOW(VFIO_TYPE, VFIO_BASE + 17,
+ *				    struct vfio_iommu_get_dirty_bitmap)
+ *
+ * Return: 0 on success, -errno on failure.
+ */
+struct vfio_iommu_get_dirty_bitmap {
+	__u64	       start_addr;
+	__u64	       page_nr;
+	__u8           dirty_bitmap[];
+};
+
+#define VFIO_IOMMU_GET_DIRTY_BITMAP _IO(VFIO_TYPE, VFIO_BASE + 17)
+
 /* -------- Additional API for SPAPR TCE (Server POWERPC) IOMMU -------- */
 
 /*
diff --git a/qemu-options.hx b/qemu-options.hx
index b1bf0f485f..09b9de6856 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -1268,6 +1268,8 @@ old style -sdl/-curses/... options. Valid values for @var{type} are
 @item sdl
 Display video output via SDL (usually in a separate graphics
 window; see the SDL documentation for other possibilities).
+@item vgt
+Intel GVT-g technology
 @item curses
 Display video output via curses. For graphics device models which
 support a text mode, QEMU can display this output using a
@@ -1501,7 +1503,7 @@ Rotate graphical output some deg left (only PXA LCD).
 ETEXI
 
 DEF("vga", HAS_ARG, QEMU_OPTION_vga,
-    "-vga [std|cirrus|vmware|qxl|xenfb|tcx|cg3|virtio|none]\n"
+    "-vga [std|cirrus|vmware|qxl|xenfb|tcx|cg3|xengt|none]\n"
     "                select video card type\n", QEMU_ARCH_ALL)
 STEXI
 @item -vga @var{type}
@@ -1536,11 +1538,42 @@ for sun4m machines available in both 1024x768 (OpenBIOS) and 1152x900 (OBP)
 resolutions aimed at people wishing to run older Solaris versions.
 @item virtio
 Virtio VGA card.
+@item xengt
+Intel IGD card based on mediated pass-through technique. A single
+IGD card can be used to accelerate multiple VMs, which each run
+native graphics driver inside.
 @item none
 Disable VGA card.
 @end table
 ETEXI
 
+DEF("vgt_low_gm_sz", 1, QEMU_OPTION_vgt_low_gm_sz,
+    "-vgt_low_gm_sz [MB] allocated aperture size\n",
+    QEMU_ARCH_ALL)
+STEXI
+@item -vgt_low_gm_sz @var{size}
+@findex -vgt_low_gm_sz
+Set the allocated aperture size.
+ETEXI
+
+DEF("vgt_high_gm_sz", 1, QEMU_OPTION_vgt_high_gm_sz,
+    "-vgt_high_gm_sz [MB] allocated GM size\n",
+    QEMU_ARCH_ALL)
+STEXI
+@item -vgt_high_gm_sz @var{size}
+@findex -vgt_high_gm_sz
+Set the allocated aperture size.
+ETEXI
+
+DEF("vgt_fence_sz", 1, QEMU_OPTION_vgt_fence_sz,
+    "-vgt_fence_sz [num] allocated number of fence registers\n",
+    QEMU_ARCH_ALL)
+STEXI
+@item -vgt_fence_sz @var{size}
+@findex -vgt_fence_sz
+Set the allocated aperture size.
+ETEXI
+
 DEF("full-screen", 0, QEMU_OPTION_full_screen,
     "-full-screen    start in full screen\n", QEMU_ARCH_ALL)
 STEXI
diff --git a/vl.c b/vl.c
index 16b913f9d5..d7353b4c72 100644
--- a/vl.c
+++ b/vl.c
@@ -1964,6 +1964,11 @@ static VGAInterfaceInfo vga_interfaces[VGA_TYPE_MAX] = {
     [VGA_XENFB] = {
         .opt_name = "xenfb",
     },
+    [VGA_VGT] = {
+        .opt_name = "xengt",
+        .name = "Intel GVT-g",
+        .class_names = { "vgt-vga" },
+    },
 };
 
 static bool vga_interface_available(VGAInterfaceType t)
@@ -1989,9 +1994,10 @@ static void select_vgahw(const char *p)
                 error_report("%s not available", ti->name);
                 exit(1);
             }
-            vga_interface_type = t;
-            break;
-        }
+	    vga_interface_type = t;
+	    printf("%s vga is %s\n", __func__, ti->opt_name);
+	    break;
+	}
     }
     if (t == VGA_TYPE_MAX) {
     invalid_vga:
@@ -2011,6 +2017,7 @@ static void select_vgahw(const char *p)
         } else goto invalid_vga;
         opts = nextopt;
     }
+
 }
 
 static void parse_display_qapi(const char *optarg)
@@ -3959,6 +3966,26 @@ int main(int argc, char **argv, char **envp)
                     exit(1);
                 }
                 break;
+#ifdef CONFIG_VGT
+            case QEMU_OPTION_vgt_low_gm_sz:
+                {
+                    char *ptr;
+                    vgt_low_gm_sz = strtol(optarg, &ptr, 10);
+                }
+                break;
+            case QEMU_OPTION_vgt_high_gm_sz:
+                {
+                    char *ptr;
+                    vgt_high_gm_sz = strtol(optarg, &ptr, 10);
+                }
+                break;
+            case QEMU_OPTION_vgt_fence_sz:
+                {
+                    char *ptr;
+                    vgt_fence_sz = strtol(optarg, &ptr, 10);
+                }
+                break;
+#endif
             case QEMU_OPTION_nodefconfig:
             case QEMU_OPTION_nouserconfig:
                 /* Nothing to be parsed here. Especially, do not error out below. */
